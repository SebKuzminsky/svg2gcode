#!/usr/bin/env python

#
# svg2gcode - a program for writing g-code from SVG files
#
# Copyright (C) 2018 Sebastian Kuzminsky
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# 

from __future__ import print_function

import argparse
import json
import jsonschema
import math
import os
import sys

import gcoder

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'svgpathtools'))
import svgpathtools


class Result(object):
    """Abstract class to hold the result of an Operation."""

    def __init__(self):
        self.comment = []
        pass

    def emit(self):
        pass


class ResultGCode(Result):
    """This class holds an array of prepared G-code statements to emit."""

    def __init__(self, *gcode):
        self.comment = []
        self.gcode = gcode

    def emit(self):
        for line in self.gcode:
            print(line)


class ResultComment(Result):
    """This class holds a G-code comment to emit."""

    def __init__(self, comment):
        self.comment = [comment]

    def emit(self):
        for comment in self.comment:
            print(";", comment)


class ResultFeed(Result):
    """This class holds a G-code F-word to emit."""

    def __init__(self, feed):
        self.comment = []
        self.feed = feed

    def emit(self):
        gcoder.set_feed_rate(self.feed)


class ResultDrill(Result):
    """This class holds the (X, Y) coordinate of a hole to drill."""

    def __init__(self, x, y, z_traverse, z_approach, z_cut_depth, plunge_feed, comment=None):
        self.comment = []
        if comment == None:
            pass;
        elif type(comment) == list:
            self.comment = comment
        else:
            self.comment.append(comment)

        self.x = x
        self.y = y
        self.z_traverse = z_traverse
        self.z_approach = z_approach
        self.z_cut_depth = z_cut_depth
        self.plunge_feed = plunge_feed

    def emit(self):
        for c in self.comment:
            gcoder.comment(c)

        gcoder.spindle_on()
        gcoder.g0(z=self.z_traverse)
        gcoder.g0(x=self.x, y=self.y)
        gcoder.set_feed_rate(self.plunge_feed)
        gcoder.g0(z=self.z_approach)
        gcoder.g81(z=self.z_cut_depth, retract=self.z_approach)
        gcoder.g0(z=self.z_traverse)


class ResultPath(Result):
    """This class holds the result of an Operation that produces a Path,
    to be turned into a sequence of G-code feed moves."""

    def __init__(self, svg, path, comment=None, z_traverse=10, z_approach=None, z_top_of_material=0, z_cut_depth=0, lead_in=True, lead_out=True, feed=None, plunge_feed=None, ramp_slope=None, max_depth_of_cut=None, work_holding_tabs=0, work_holding_tab_height=0.5, work_holding_tab_width=10.0, work_holding_tab_locations=[]):
        self.comment = []
        if comment == None:
            pass;
        elif type(comment) == list:
            self.comment = comment
        else:
            self.comment.append(comment)
        self.svg = svg
        self.path = path
        self.z_traverse = z_traverse
        self.z_approach = z_approach
        self.z_top_of_material = z_top_of_material
        self.z_cut_depth = z_cut_depth
        self.lead_in = lead_in
        self.lead_out = lead_out
        self.feed = feed
        self.plunge_feed = plunge_feed
        self.ramp_slope = ramp_slope
        self.max_depth_of_cut = max_depth_of_cut
        self.work_holding_tabs = work_holding_tabs
        self.work_holding_tab_height = work_holding_tab_height
        self.work_holding_tab_width = work_holding_tab_width
        self.work_holding_tab_locations = work_holding_tab_locations

    def emit(self):
        for c in self.comment:
            gcoder.comment(c)
        gcoder.path_to_gcode(
            self.svg,
            self.path,
            z_traverse=self.z_traverse,
            z_approach=self.z_approach,
            z_top_of_material=self.z_top_of_material,
            z_cut_depth=self.z_cut_depth,
            lead_in=self.lead_in,
            lead_out=self.lead_out,
            feed=self.feed,
            plunge_feed=self.plunge_feed,
            max_depth_of_cut=self.max_depth_of_cut,
            ramp_slope=self.ramp_slope,
            work_holding_tabs=self.work_holding_tabs,
            work_holding_tab_height=self.work_holding_tab_height,
            work_holding_tab_width=self.work_holding_tab_width,
            work_holding_tab_locations=self.work_holding_tab_locations,
            debug=args.debug
        )


def handle_operation(op, path_index):
    print("operation:", op, file=sys.stderr)
    print("path:", path_index, file=sys.stderr)

    input_path = svg.paths[path_index]

    input_path = gcoder.close_path(input_path)
    if not input_path.isclosed():
        raise ValueError("path is not closed")

    # positive area == clockwise path
    # negative area == counter-clockwise path
    # Make sure the input path is counter-clockwise.
    # FIXME: Only process counter-clockwise paths.  Clockwise paths are islands.  (Or the other way around)
    if gcoder.approximate_path_area(input_path) > 0:
        input_path = input_path.reversed()

    results = []
    results.append(ResultComment("%s, path %d" % (op.keys()[0], path_index)))

    if 'engrave' in op:
        results += do_engrave(op['engrave'], input_path)

    elif 'offset' in op:
        results += do_offset(op['offset'], input_path)

    elif 'pocket' in op:
        results += do_pocket(op['pocket'], input_path)

    elif 'drill' in op:
        results += do_drill(op['drill'], input_path)

    else:
        raise SystemExit('unknown operation %s' % op)

    return results


def do_engrave(op_args, input_path):
    ramp_slope = None
    if "ramp-slope" in op_args.keys():
        ramp_slope = op_args['ramp-slope']

    result = ResultPath(
        comment = "engrave path",
        svg=svg,
        path=input_path,
        z_traverse=args.z_traverse,
        z_approach=args.z_approach,
        z_top_of_material=args.z_top_of_material,
        z_cut_depth=args.z_cut_depth,
        plunge_feed=args.plunge_feed,
        feed=args.feed,
        ramp_slope=ramp_slope
    )

    return [result]


def do_offset(op_args, input_path):
    offset = op_args['distance']
    output_paths = gcoder.offset_paths(input_path, offset, debug=args.debug)

    max_depth_of_cut = None
    if "max-depth-of-cut" in op_args.keys():
        max_depth_of_cut = op_args['max-depth-of-cut']
    else:
        cut_depth = args.z_top_of_material - args.z_cut_depth
        print("WARNING: no 'max-depth-of-cut' specified in job, slotting from --z-top-of-material (%f) down to --z-cut-depth (%f), total %f, in one pass" % (args.z_top_of_material, args.z_cut_depth, cut_depth), file=sys.stderr)

    ramp_slope = None
    if "ramp-slope" in op_args.keys():
        ramp_slope = op_args['ramp-slope']

    work_holding_tabs = 0
    work_holding_tab_height = 0.5
    work_holding_tab_width = 10.0
    work_holding_tab_locations = []
    if "work-holding-tabs" in op_args.keys():
        tabs = op_args['work-holding-tabs']
        if "number-of-tabs" in tabs.keys():
            work_holding_tabs = tabs['number-of-tabs']
        if "height" in tabs.keys():
            work_holding_tab_height = tabs['height']
        if "width" in tabs.keys():
            work_holding_tab_width = tabs['width']
        if "locations" in tabs.keys():
            work_holding_tab_locations = tabs['locations']

        if work_holding_tabs > 0 and len(work_holding_tab_locations) != 0:
            if work_holding_tabs != len(work_holding_tab_locations):
                raise ValueError("number of work holding tabs requested (%d) does not match number of locations specified (%d)" % (work_holding_tabs, len(work_holding_tab_locations)))

    results = []
    for i in range(len(output_paths)):
        result = ResultPath(
            comment = "offset path (%f offset) %d/%d" % (op_args['distance'], i+1, len(output_paths)),
            svg = svg,
            path = output_paths[i],
            z_traverse=args.z_traverse,
            z_approach=args.z_approach,
            z_top_of_material=args.z_top_of_material,
            z_cut_depth=args.z_cut_depth,
            lead_in=True,
            lead_out=True,
            plunge_feed=args.plunge_feed,
            feed=args.feed,
            max_depth_of_cut=max_depth_of_cut,
            ramp_slope=ramp_slope,
            work_holding_tabs=work_holding_tabs,
            work_holding_tab_height=work_holding_tab_height,
            work_holding_tab_width=work_holding_tab_width,
            work_holding_tab_locations=work_holding_tab_locations
        )
        results.append(result)

    return results


def do_drill(op_args, input_path):
    if len(input_path) == 2 and \
        type(input_path[0]) == svgpathtools.path.Arc and \
        type(input_path[1]) == svgpathtools.path.Arc and \
        input_path[0].center == input_path[1].center and \
        input_path[0].start == input_path[1].end and \
        input_path[0].end == input_path[1].start and \
        input_path[0].radius == input_path[1].radius and \
        input_path[0].sweep == input_path[1].sweep and \
        input_path[0].radius.real == input_path[0].radius.imag:
        # input path is a circle, ok
        pass
    else:
        raise ValueError('drill job on non-circle path!')

    (x, y) = svg.xy_to_mm(input_path[0].center)
    result = ResultDrill(
        x=x,
        y=y,
        z_traverse=args.z_traverse,
        z_approach=args.z_approach,
        z_cut_depth=args.z_cut_depth,
        plunge_feed=args.plunge_feed,
        comment="hole diameter %.4f" % (input_path[0].radius.real * 2)
    )
    return [result]


def v1_handle_path(job, path_index):
    if args.debug: print("doing v1 job", file=sys.stderr)
    if args.debug: print("    job: %s" % job['job-type'], file=sys.stderr)
    if args.debug: print("    path: %s" % path_index, file=sys.stderr)

    results = []

    input_path = gcoder.close_path(svg.paths[path_index])
    if not input_path.isclosed():
        raise ValueError("path is not closed")

    # positive area == clockwise path
    # negative area == counter-clockwise path
    # Make sure the input path is counter-clockwise.
    # FIXME: Only process counter-clockwise paths.  Clockwise paths are islands.  (Or the other way around)
    if gcoder.approximate_path_area(input_path) > 0:
        input_path = input_path.reversed()

    if job['job-type'] == 'offset':
        results = do_offset(job, input_path)

    elif job['job-type'] == 'pocket':
        results = do_pocket(job, input_path)

    elif job['job-type'] == 'engrave':
        results = do_engrave(job, input_path)

    elif job['job-type'] == 'drill':
        results = do_drill(job, input_path)

    else:
        raise ValueError('unknown job type %s' % job['job-type'])

    for r in results:
        print("r: %s" % r, file=sys.stderr)
        r.comment.insert(0, "%s, path %d" % (job['job-type'], path_index))

    return results


def remove_island(island, tool_radius, width_of_cut):
    offset = -tool_radius + width_of_cut
    island_output_paths = []

    print("removing an island: %s" % island, file=sys.stderr)

    while island != None:
        print("remaining material:", island, file=sys.stderr)

        shoulder_milling_paths = gcoder.offset_paths(island, offset, debug=args.debug)

        if len(shoulder_milling_paths) == 0:
            print("no more shoulder milling paths", file=sys.stderr)
            return island_output_paths

        island_output_paths += shoulder_milling_paths

        remaining_material_contours = []
        for path in shoulder_milling_paths:
            remaining_material_contours += gcoder.offset_paths(path, tool_radius, debug=args.debug)

        num_islands = len(remaining_material_contours)
        print("%d sub-islands remaining" % num_islands, file=sys.stderr)
        if num_islands == 0:
            # Done!
            return island_output_paths

        elif num_islands == 1:
            # Just one island, iterate on it.
            island = remaining_material_contours[0]

        else:
            # Multiple islands, recurse on each one.
            for island in remaining_material_contours:
                island_output_paths += remove_island(island, tool_radius, width_of_cut)
            return island_output_paths


def do_pocket(op_args, input_path):
    #
    # Inset the material contour by the finishing allowance to
    # get the rough material contour.
    #
    # The first tool path is the perimeter slotting cut (which
    # might be wrong, shouldn't we make the smallest possible
    # slot in the middle and go out from there?). Inset the rough
    # material contour by the tool radius to get the tool path
    # for this wrong slot.
    #
    # After that we want to shoulder mill the remainder
    #
    # Inset the slotting tool path by the tool radius to find
    # the remaining material contour
    #
    # While the remaining material contour is greater than zero:
    #
    #     Outset the remaining material contour by the tool radius
    #     minus the width of cut to find the next pass tool path
    #
    #     Inset the tool path by the tool radius to find the
    #     new remaining material contour

    output_paths = []
    material_contour = input_path

    # FIXME: get these from a different tool info section of the json data
    if "tool-diameter" in op_args.keys():
        tool_diameter = op_args['tool-diameter']
    else:
        raise ValueError('no "tool-diameter" specified in "pocket" operation')
    tool_radius = tool_diameter / 2.0

    if "width-of-cut" in op_args.keys():
        width_of_cut = op_args['width-of-cut']
    else:
        raise ValueError('no "width-of-cut" specified in "pocket" operation')

    finishing_allowance = 0.0
    if "finishing-allowance" in op_args.keys():
        finishing_allowance = op_args['finishing-allowance']

    pocket_depth = args.z_top_of_material - args.z_cut_depth

    slot_max_depth_of_cut = pocket_depth
    if "slot-max-depth-of-cut" in op_args.keys():
        slot_max_depth_of_cut = op_args['slot-max-depth-of-cut']
    else:
        print("WARNING: no 'slot-max-depth-of-cut' specified in pocket operation, slotting from --z-top-of-material (%f) down to --z-cut-depth (%f), total %f, in one pass" % (args.z_top_of_material, args.z_cut_depth, pocket_depth), file=sys.stderr)

    shoulder_max_depth_of_cut = pocket_depth
    if "shoulder-max-depth-of-cut" in op_args.keys():
        shoulder_max_depth_of_cut = op_args['shoulder-max-depth-of-cut']
    else:
        print("WARNING: no 'shoulder-max-depth-of-cut' specified in pocket operation, slotting from --z-top-of-material (%f) down to --z-cut-depth (%f), total %f, in one pass" % (args.z_top_of_material, args.z_cut_depth, pocket_depth), file=sys.stderr)

    max_depth_of_cut = min(slot_max_depth_of_cut, shoulder_max_depth_of_cut)
    num_passes = math.ceil(pocket_depth / max_depth_of_cut)
    depth_of_cut = pocket_depth / num_passes

    ramp_slope = None
    if "ramp-slope" in op_args.keys():
        ramp_slope = op_args['ramp-slope']


    #
    # Compute initial slotting paths.
    #

    offset = finishing_allowance + tool_radius
    slotting_paths = gcoder.offset_paths(material_contour, offset, debug=args.debug)
    if not slotting_paths:
        print("no slotting path!", file=sys.stderr)
        return []
    output_paths += slotting_paths
    print("initial slotting path(s): %s" % slotting_paths, file=sys.stderr)


    #
    # Compute shoulder milling paths.
    #

    shoulder_milling_paths = []
    for slot in slotting_paths:
        remaining_material_contours = gcoder.offset_paths(slot, tool_radius, debug=args.debug)
        print("remaining material contours (islands): %s" % remaining_material_contours, file=sys.stderr)
        output_paths += remaining_material_contours
        # FIXME: sort the remaining islands, nearest first
        for island in remaining_material_contours:
            shoulder_milling_paths += remove_island(island, tool_radius, width_of_cut)
    output_paths += shoulder_milling_paths


    #
    # Emit all the g-code.
    #
    results = []
    pass_num = 0
    while pass_num < num_passes:
        pass_num += 1
        z = args.z_top_of_material - (depth_of_cut * pass_num)
        z_prev = args.z_top_of_material - (depth_of_cut * (pass_num - 1))

        for path in slotting_paths:
            result = ResultPath(
                comment="slotting cut %d/%d, z=%f, %.4f finishing allowance + %.4f tool radius" % (pass_num, num_passes, z, finishing_allowance, tool_radius),
                svg=svg,
                path=path,
                z_traverse=args.z_traverse,
                z_approach=args.z_approach,
                z_top_of_material=z_prev,
                z_cut_depth=z,
                lead_in=True,
                lead_out=False,
                plunge_feed=args.plunge_feed,
                feed=args.slot_feed,
                ramp_slope=ramp_slope
            )
            results.append(result)

        for path in shoulder_milling_paths:
            # The tool is currently down on the floor of the pocket.

            results.append(ResultComment("pocket shoulder-milling path"))

            # FIXME: if we can reach it without gouging, just feed there
            # else this:
            (x, y) = svg.xy_to_mm(path[0].start)
            if gcoder.current_z < args.z_approach:
                results.append(ResultGCode("G1 Z%.4f" % args.z_approach))
            if gcoder.current_z < args.z_traverse:
                results.append(ResultGCode("G0 Z%.4f" % args.z_traverse))
            results.append(ResultGCode("G0 X%.4f Y%.4f" % (x, y)))
            results.append(ResultGCode("G0 Z%.4f" % args.z_approach))
            results.append(ResultFeed(args.plunge_feed))
            results.append(ResultGCode("G1 Z%.4f" % z))

            result = ResultPath(
                svg=svg,
                path=path,
                z_traverse=args.z_traverse,
                z_approach=args.z_approach,
                z_top_of_material=z_prev,
                z_cut_depth=z,
                lead_in=False,
                lead_out=False,
                feed=args.shoulder_feed
            )
            results.append(result)

    # The tool is left down on the floor of the pocket, raise it
    # up now.
    results.append(ResultGCode("G1 Z%.4f" % args.z_approach))
    results.append(ResultGCode("G0 Z%.4f" % args.z_traverse))

    return results


def load_job_file(jobfile):
    work_holding_tabs_schema = {
        'type': 'object',
        'properties': {
            'number-of-tabs': {
                'type': 'number'
            },
            'height': {
                'type': 'number'
            },
            'width': {
                'type': 'number'
            },
            'locations': {
                'type': 'array',
                'items': {
                    'type': 'number'
                }
            }
        },
        'additionalProperties': False
    }

    v1_schema = {
        'type': 'object',
        'properties': {
            'jobs': {
                'type': 'array',
                'items': {
                    'type': 'object',
                    'properties': {
                        'job-type': {
                            'type': 'string'
                        },
                        'comment': {
                            'type': 'string'
                        },
                        'ramp-slope': {
                            'type': 'number'
                        },
                        'distance': {
                            'type': 'number'
                        },
                        'max-depth-of-cut': {
                            'type': 'number'
                        },
                        'tool-diameter': {
                            'type': 'number'
                        },
                        'width-of-cut': {
                            'type': 'number'
                        },
                        'slot-max-depth-of-cut': {
                            'type': 'number'
                        },
                        'shoulder-max-depth-of-cut': {
                            'type': 'number'
                        },
                        'finishing-allowance': {
                            'type': 'number'
                        },
                        'work-holding-tabs': work_holding_tabs_schema
                    },
                    'required': [ 'job-type' ],
                    'additionalProperties': False
                }
            }
        },
        'additionalProperties': False
    }

    v2_schema = {
        'type': 'object',
        'properties': {
            'jobs': {
                'type': 'array',
                'items': {
                    'type': 'object',
                    'properties': {
                        'paths': {
                            'type': 'array',
                            'items': {
                                'type': 'number'
                            }
                        },
                        'operations': {
                            'type': 'array',
                            'items': {
                                'type': 'object',
                                'properties': {
                                    'engrave': {
                                        'type': 'object',
                                        'properties': {
                                            'ramp-slope': {
                                                'type': 'number'
                                            }
                                        },
                                        'additionalProperties': False
                                    },
                                    'offset': {
                                        'type': 'object',
                                        'properties': {
                                            'distance': {
                                                'type': 'number'
                                            },
                                            'max-depth-of-cut': {
                                                'type': 'number'
                                            },
                                            'ramp-slope': {
                                                'type': 'number'
                                            },
                                            'work-holding-tabs': work_holding_tabs_schema
                                        },
                                        'additionalProperties': False
                                    },
                                    'pocket': {
                                        'type': 'object',
                                        'properties': {
                                            'tool-diameter': {
                                                'type': 'number'
                                            },
                                            'width-of-cut': {
                                                'type': 'number'
                                            },
                                            'finishing-allowance': {
                                                'type': 'number'
                                            },
                                            'slot-max-depth-of-cut': {
                                                'type': 'number'
                                            },
                                            'shoulder-max-depth-of-cut': {
                                                'type': 'number'
                                            },
                                            'ramp-slope': {
                                                'type': 'number'
                                            }
                                        },
                                        'additionalProperties': False
                                    },
                                    'drill': {
                                        'type': 'object',
                                        'properties': { },
                                        'additionalProperties': False
                                    }
                                },
                                'additionalProperties': False
                            }
                        }
                    },
                    'additionalProperties': False
                }
            }
        },
        'additionalProperties': False
    }

    jobs = json.load(open(jobfile))

    jobfile_schema = None
    try:
        jsonschema.validate(jobs, v2_schema)
        jobfile_schema = 2
    except Exception as v2_e:
        try:
            jsonschema.validate(jobs, v1_schema)
            jobfile_schema = 1
        except Exception as v1_e:
            print("json fails schema validation (both v1 and v2)!", file=sys.stderr)
            print("v1 schema failure:", file=sys.stderr)
            print(v1_e, file=sys.stderr)
            print("v2 schema failure:", file=sys.stderr)
            print(v2_e, file=sys.stderr)
            raise SystemExit(1)

    return jobs, jobfile_schema


parser = argparse.ArgumentParser(description="Compute g-code operations from the closed paths in an SVG file.")
parser.add_argument("JOBFILE", help="Read machining job parameters from this file.")
parser.add_argument("SVG", help="The name of the SVG file to read.")
parser.add_argument("-p", "--path", type=int, action='append', help="Apply the machining operations to this path (specified as an index into the list of paths in the input SVG).  May be used multiple times to apply the operations to multiple paths.  (Default: apply to all paths.)")
parser.add_argument("-s", "--speed", type=int, help="The spindle speed to use, in RPM.  (Default: 1000 rpm.)")
parser.add_argument("-f", "--feed", type=float, help="The tool feed rate to use, in mm/minute.  Used by the 'engrave' and 'offset' job types.  (Default: 100.0 mm/min)")
parser.add_argument("--shoulder-feed", type=float, help="The tool feed rate to use for shoulder milling, in mm/minute.  Used by the 'pocket' operation.  (Default: 90.0 mm/min)")
parser.add_argument("--slot-feed", type=float, help="The tool feed rate to use for slot milling, in mm/minute.  Used by the 'pocket' operation'.  (Default: 75.0 mm/min)")
parser.add_argument("--plunge-feed", type=float, help="The tool feed rate to use for plunging cuts, in mm/minute.  Used by all job types.  (Default: 50.0 mm/min)")
parser.add_argument("--z-traverse", type=float, help="The Z level for safe traverses above the work and workholding.  (Default: 10)", default=10)
parser.add_argument("--z-approach", type=float, help="The Z level down to which we should rapid, before slowing to the feed rate to approach the work.  (Default: 0.5 mm above z-top-of-material)", default=None)
parser.add_argument("--z-top-of-material", type=float, help="The Z level where the cutting starts.  (Default: 0)", default=0)
parser.add_argument("--z-cut-depth", type=float, help="The Z level to cut down to.  Must be lower than --z-top-of-material.  (Default: -1)", default=-1.0)
parser.add_argument("--debug", action="store_true", help="Generate debugging output on stderr.  Useful for submitting bug reports.")
args = parser.parse_args()

if args.speed == None:
    print("WARNING: no --speed argument supplied, using the default 1000 rpm", file=sys.stderr)
    args.speed = 1000

if args.feed == None:
    print("WARNING: no --feed argument supplied, using the default 100 mm/min", file=sys.stderr)
    args.feed = 100.0

if args.shoulder_feed == None:
    print("WARNING: no --shoulder-feed argument supplied, using the default 90 mm/min", file=sys.stderr)
    args.shoulder_feed = 90

if args.slot_feed == None:
    print("WARNING: no --slot-feed argument supplied, using the default 75 mm/min", file=sys.stderr)
    args.slot_feed = 75

if args.plunge_feed == None:
    print("WARNING: no --plunge-feed argument supplied, using the default 50 mm/min", file=sys.stderr)
    args.plunge_feed = 50

if args.z_approach == None:
    args.z_approach = 0.5 + args.z_top_of_material

if args.z_top_of_material <= args.z_cut_depth:
    raise ValueError("--z-top-of-material (%f) is not above --z-cut-depth (%f)" % (args.z_top_of_material, args.z_cut_depth))

jobs, jobfile_schema = load_job_file(args.JOBFILE)
svg = gcoder.svg(args.SVG)

# G-code preamble
gcoder.metric()
gcoder.path_blend(tolerance=0.01)
gcoder.speed(args.speed)

results = []


# Old-style job files have a single top-level property named "jobs",
# which is an array of v1 job objects.  Iterate over the paths from the
# command line, and run all jobs on each.
if jobfile_schema == 1:
    if args.path == None:
        args.path = range(0, len(svg.paths))
    for path_index in args.path:
        for job in jobs['jobs']:
            results += v1_handle_path(job, path_index)

# New-style job files have a single top-level property named "jobs",
# which is an array of v2 job objects.
elif jobfile_schema == 2:
    for job in jobs['jobs']:
        input_paths = None
        if type(args.path) is list and len(args.path) > 0:
            input_paths = args.path
        elif 'paths' in job:
            input_paths = job['paths']
        else:
            input_paths = range(0, len(svg.paths))
        for path in input_paths:
            for op in job['operations']:
                results += handle_operation(op, path)


output_paths = []
for result in results:
    result.emit()
    if type(result) == ResultPath:
        output_paths += result.path


if args.debug:
    print("output paths: %s" % output_paths, file=sys.stderr)
    if len(output_paths) > 0:
        svgpathtools.paths2svg.wsvg(paths=output_paths)

# G-code postamble
gcoder.m2()
