#!/usr/bin/env python

#
# svg2gcode - a program for writing g-code from SVG files
#
# Copyright (C) 2018 Sebastian Kuzminsky
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# 

from __future__ import print_function

import argparse
import json
import jsonschema
import math
import os
import sys

import gcoder

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'svgpathtools'))
import svgpathtools


def handle_operation(op, path_index):
    print("operation:", op, file=sys.stderr)
    print("path:", path_index, file=sys.stderr)

    input_path = svg.paths[path_index]

    input_path = gcoder.close_path(input_path)
    if not input_path.isclosed():
        raise ValueError("path is not closed")

    # positive area == clockwise path
    # negative area == counter-clockwise path
    # Make sure the input path is counter-clockwise.
    # FIXME: Only process counter-clockwise paths.  Clockwise paths are islands.  (Or the other way around)
    if gcoder.approximate_path_area(input_path) > 0:
        input_path = input_path.reversed()

    if 'engrave' in op:
        return do_engrave(op['engrave'], input_path)

    elif 'offset' in op:
        return do_offset(op['offset'], input_path)

    elif 'pocket2' in op:
        return do_pocket2(op['pocket2'], input_path)

    elif 'drill' in op:
        return do_drill(op['drill'], input_path)

    else:
        raise SystemExit('unknown operation %s' % op)


def do_engrave(op_args, input_path):
    ramp_slope = None
    if "ramp-slope" in op_args.keys():
        ramp_slope = op_args['ramp-slope']

    gcoder.comment("engrave path")
    gcoder.path_to_gcode(
        svg,
        input_path,
        z_traverse=args.z_traverse,
        z_approach=args.z_approach,
        z_top_of_material=args.z_top_of_material,
        z_cut_depth=args.z_cut_depth,
        plunge_feed=args.plunge_feed,
        feed=args.feed,
        ramp_slope=ramp_slope
    )

    return [input_path]


def do_offset(op_args, input_path):
    offset = op_args['distance']
    output_paths = gcoder.offset_paths(input_path, offset, debug=args.debug)

    max_depth_of_cut = None
    if "max-depth-of-cut" in op_args.keys():
        max_depth_of_cut = op_args['max-depth-of-cut']
    else:
        cut_depth = args.z_top_of_material - args.z_cut_depth
        print("WARNING: no 'max-depth-of-cut' specified in job, slotting from --z-top-of-material (%f) down to --z-cut-depth (%f), total %f, in one pass" % (args.z_top_of_material, args.z_cut_depth, cut_depth), file=sys.stderr)

    ramp_slope = None
    if "ramp-slope" in op_args.keys():
        ramp_slope = op_args['ramp-slope']

    work_holding_tabs = 0
    work_holding_tab_height = 0.5
    work_holding_tab_width = 10.0
    work_holding_tab_locations = []
    if "work-holding-tabs" in op_args.keys():
        tabs = op_args['work-holding-tabs']
        if "number-of-tabs" in tabs.keys():
            work_holding_tabs = tabs['number-of-tabs']
        if "height" in tabs.keys():
            work_holding_tab_height = tabs['height']
        if "width" in tabs.keys():
            work_holding_tab_width = tabs['width']
        if "locations" in tabs.keys():
            work_holding_tab_locations = tabs['locations']

        if work_holding_tabs > 0 and len(work_holding_tab_locations) != 0:
            if work_holding_tabs != len(work_holding_tab_locations):
                raise ValueError("number of work holding tabs requested (%d) does not match number of locations specified (%d)" % (work_holding_tabs, len(work_holding_tab_locations)))

    for i in range(len(output_paths)):
        gcoder.comment("offset path (%f offset) %d/%d" % (op_args['distance'], i+1, len(output_paths)))
        path = output_paths[i]
        gcoder.path_to_gcode(
            svg,
            path,
            z_traverse=args.z_traverse,
            z_approach=args.z_approach,
            z_top_of_material=args.z_top_of_material,
            z_cut_depth=args.z_cut_depth,
            lead_in=True,
            lead_out=True,
            plunge_feed=args.plunge_feed,
            feed=args.feed,
            max_depth_of_cut=max_depth_of_cut,
            ramp_slope=ramp_slope,
            work_holding_tabs=work_holding_tabs,
            work_holding_tab_height=work_holding_tab_height,
            work_holding_tab_width=work_holding_tab_width,
            work_holding_tab_locations=work_holding_tab_locations,
            debug=args.debug
        )

    return output_paths


def do_drill(op_args, input_path):
    if len(input_path) == 2 and \
        type(input_path[0]) == svgpathtools.path.Arc and \
        type(input_path[1]) == svgpathtools.path.Arc and \
        input_path[0].center == input_path[1].center and \
        input_path[0].start == input_path[1].end and \
        input_path[0].end == input_path[1].start and \
        input_path[0].radius == input_path[1].radius and \
        input_path[0].sweep == input_path[1].sweep and \
        input_path[0].radius.real == input_path[0].radius.imag:
        # input path is a circle, ok
        pass
    else:
        raise ValueError('drill job on non-circle path!')

    gcoder.comment("drilling (hole diameter %.4f)" % (input_path[0].radius.real * 2))
    gcoder.spindle_on()
    (x, y) = svg.to_mm(input_path[0].center)
    gcoder.g0(z=args.z_traverse)
    gcoder.g0(x=x, y=y)
    gcoder.set_feed_rate(args.plunge_feed)
    gcoder.g0(z=args.z_approach)
    gcoder.g81(z=args.z_cut_depth, retract=args.z_approach)
    gcoder.g0(z=args.z_traverse)

    # no output path for drill ops
    return []


def do_pocket(op_args, input_path):
    output_paths = []

    # FIXME: get these from a different tool info section of the json data
    if "tool-diameter" in op_args.keys():
        tool_diameter = op_args['tool-diameter']
    else:
        raise ValueError('no "tool-diameter" specified in "pocket" operation')
    tool_radius = tool_diameter / 2.0

    if "width-of-cut" in op_args.keys():
        width_of_cut = op_args['width-of-cut']
    else:
        raise ValueError('no "width-of-cut" specified in "pocket" operation')

    finishing_allowance = 0.0
    if "finishing-allowance" in op_args.keys():
        finishing_allowance = op_args['finishing-allowance']

    offset = finishing_allowance + tool_radius
    output_paths = gcoder.offset_paths(input_path, offset, debug=args.debug)
    if not output_paths:
        # can't fit the tool into this path, nothing to do
        print("pocket fails: tool too large to fit into path", file=sys.stderr)
        return []

    gcoder.comment("slotting the largest profile, %.4f finishing allowance + %.4f tool radius" % (finishing_allowance, tool_radius))
    for path in output_paths:
        gcoder.path_to_gcode(
            svg,
            path,
            z_traverse=args.z_traverse,
            z_approach=args.z_approach,
            z_top_of_material=args.z_top_of_material,
            z_cut_depth=args.z_cut_depth,
            plunge_feed=args.plunge_feed,
            feed=args.feed
        )

    while True:
        offset += width_of_cut
        new_paths = gcoder.offset_paths(input_path, offset, debug=args.debug)
        if not new_paths:
            break
        for path in new_paths:
            gcoder.comment("pocket path (%.4f offset)" % offset)
            gcoder.path_to_gcode(
                svg,
                path,
                z_traverse=args.z_traverse,
                z_approach=args.z_approach,
                z_top_of_material=args.z_top_of_material,
                z_cut_depth=args.z_cut_depth,
                plunge_feed=args.plunge_feed,
                feed=args.feed
            )
        output_paths += new_paths

    return output_paths


def v1_handle_path(job, input_path):
    output_paths = []

    input_path = gcoder.close_path(input_path)
    if not input_path.isclosed():
        raise ValueError("path is not closed")

    # positive area == clockwise path
    # negative area == counter-clockwise path
    # Make sure the input path is counter-clockwise.
    # FIXME: Only process counter-clockwise paths.  Clockwise paths are islands.  (Or the other way around)
    if gcoder.approximate_path_area(input_path) > 0:
        input_path = input_path.reversed()

    if job['job-type'] == 'offset':
        output_paths = do_offset(job, input_path)

    elif job['job-type'] == 'pocket':
        output_paths = do_pocket(job, input_path)

    elif job['job-type'] == 'pocket2':
        output_paths = do_pocket2(job, input_path)

    elif job['job-type'] == 'engrave':
        output_paths = do_engrave(job, input_path)

    elif job['job-type'] == 'drill':
        output_paths = do_drill(job, input_path)

    else:
        raise ValueError('unknown job type %s' % job['job-type'])

    return output_paths


def remove_island(island, tool_radius, width_of_cut):
    offset = -tool_radius + width_of_cut
    island_output_paths = []

    print("removing an island", file=sys.stderr)

    while island != None:
        print("remaining material:", island, file=sys.stderr)

        shoulder_milling_paths = gcoder.offset_paths(island, offset, debug=args.debug)

        if len(shoulder_milling_paths) == 0:
            print("no more shoulder milling paths", file=sys.stderr)
            return island_output_paths

        island_output_paths += shoulder_milling_paths

        remaining_material_contours = []
        for path in shoulder_milling_paths:
            remaining_material_contours += gcoder.offset_paths(path, tool_radius, debug=args.debug)

        num_islands = len(remaining_material_contours)
        print("%d sub-islands remaining" % num_islands, file=sys.stderr)
        if num_islands == 0:
            # Done!
            return island_output_paths

        elif num_islands == 1:
            # Just one island, iterate on it.
            island = remaining_material_contours[0]

        else:
            # Multiple islands, recurse on each one.
            for island in remaining_material_contours:
                island_output_paths += remove_island(island, tool_radius, width_of_cut)
            return island_output_paths


def do_pocket2(op_args, input_path):
    # Alternative pocketing algorithm.
    #
    # Inset the material contour by the finishing allowance to
    # get the rough material contour.
    #
    # The first tool path is the perimeter slotting cut (which
    # might be wrong, shouldn't we make the smallest possible
    # slot in the middle and go out from there?). Inset the rough
    # material contour by the tool radius to get the tool path
    # for this wrong slot.
    #
    # After that we want to shoulder mill the remainder
    #
    # Inset the slotting tool path by the tool radius to find
    # the remaining material contour
    #
    # While the remaining material contour is greater than zero:
    #
    #     Outset the remaining material contour by the tool radius
    #     minus the width of cut to find the next pass tool path
    #
    #     Inset the tool path by the tool radius to find the
    #     new remaining material contour

    output_paths = []
    material_contour = input_path

    # FIXME: get these from a different tool info section of the json data
    if "tool-diameter" in op_args.keys():
        tool_diameter = op_args['tool-diameter']
    else:
        raise ValueError('no "tool-diameter" specified in "pocket" operation')
    tool_radius = tool_diameter / 2.0

    if "width-of-cut" in op_args.keys():
        width_of_cut = op_args['width-of-cut']
    else:
        raise ValueError('no "width-of-cut" specified in "pocket" operation')

    finishing_allowance = 0.0
    if "finishing-allowance" in op_args.keys():
        finishing_allowance = op_args['finishing-allowance']

    pocket_depth = args.z_top_of_material - args.z_cut_depth

    slot_max_depth_of_cut = pocket_depth
    if "slot-max-depth-of-cut" in op_args.keys():
        slot_max_depth_of_cut = op_args['slot-max-depth-of-cut']
    else:
        print("WARNING: no 'slot-max-depth-of-cut' specified in pocket operation, slotting from --z-top-of-material (%f) down to --z-cut-depth (%f), total %f, in one pass" % (args.z_top_of_material, args.z_cut_depth, pocket_depth), file=sys.stderr)

    shoulder_max_depth_of_cut = pocket_depth
    if "shoulder-max-depth-of-cut" in op_args.keys():
        shoulder_max_depth_of_cut = op_args['shoulder-max-depth-of-cut']
    else:
        print("WARNING: no 'shoulder-max-depth-of-cut' specified in pocket operation, slotting from --z-top-of-material (%f) down to --z-cut-depth (%f), total %f, in one pass" % (args.z_top_of_material, args.z_cut_depth, pocket_depth), file=sys.stderr)

    max_depth_of_cut = min(slot_max_depth_of_cut, shoulder_max_depth_of_cut)
    num_passes = math.ceil(pocket_depth / max_depth_of_cut)
    depth_of_cut = pocket_depth / num_passes

    ramp_slope = None
    if "ramp-slope" in op_args.keys():
        ramp_slope = op_args['ramp-slope']


    #
    # Compute initial slotting paths.
    #

    offset = finishing_allowance + tool_radius
    slotting_paths = gcoder.offset_paths(material_contour, offset, debug=args.debug)
    if not slotting_paths:
        print("no slotting path!", file=sys.stderr)
        return []
    output_paths += slotting_paths


    #
    # Compute shoulder milling paths.
    #

    shoulder_milling_paths = []
    for slot in slotting_paths:
        remaining_material_contours = gcoder.offset_paths(slot, tool_radius, debug=args.debug)
        # FIXME: sort the remaining islands, nearest first
        for island in remaining_material_contours:
            shoulder_milling_paths += remove_island(island, tool_radius, width_of_cut)
    output_paths += shoulder_milling_paths


    #
    # Emit all the g-code.
    #
    pass_num = 0
    while pass_num < num_passes:
        pass_num += 1
        z = args.z_top_of_material - (depth_of_cut * pass_num)
        z_prev = args.z_top_of_material - (depth_of_cut * (pass_num - 1))

        for path in slotting_paths:
            gcoder.comment("slotting cut %d/%d, z=%f, %.4f finishing allowance + %.4f tool radius" % (pass_num, num_passes, z, finishing_allowance, tool_radius))
            gcoder.path_to_gcode(
                svg,
                path,
                z_traverse=args.z_traverse,
                z_approach=args.z_approach,
                z_top_of_material=z_prev,
                z_cut_depth=z,
                lead_in=True,
                lead_out=False,
                plunge_feed=args.plunge_feed,
                feed=args.slot_feed,
                ramp_slope=ramp_slope
            )

        for path in shoulder_milling_paths:
            # The tool is currently down on the floor of the pocket.

            gcoder.comment("pocket shoulder-milling path")

            # FIXME: if we can reach it without gouging, just feed there
            # else this:
            (x, y) = svg.to_mm(path[0].start)
            if gcoder.current_z < args.z_approach:
                gcoder.g1(z=args.z_approach)
            if gcoder.current_z < args.z_traverse:
                gcoder.g0(z=args.z_traverse)
            gcoder.g0(x=x, y=y)
            gcoder.g0(z=args.z_approach)
            gcoder.set_feed_rate(args.plunge_feed)
            gcoder.g1(z=z)

            gcoder.path_to_gcode(
                svg,
                path,
                z_traverse=args.z_traverse,
                z_approach=args.z_approach,
                z_top_of_material=z_prev,
                z_cut_depth=z,
                lead_in=False,
                lead_out=False,
                feed=args.shoulder_feed
            )

    # The tool is left down on the floor of the pocket, raise it
    # up now.
    gcoder.g1(z=args.z_approach)
    gcoder.g0(z=args.z_traverse)

    return output_paths


def load_job_file(jobfile):
    work_holding_tabs_schema = {
        'type': 'object',
        'properties': {
            'number-of-tabs': {
                'type': 'number'
            },
            'height': {
                'type': 'number'
            },
            'width': {
                'type': 'number'
            },
            'locations': {
                'type': 'array',
                'items': {
                    'type': 'number'
                }
            }
        },
        'additionalProperties': False
    }

    v1_schema = {
        'type': 'object',
        'properties': {
            'jobs': {
                'type': 'array',
                'items': {
                    'type': 'object',
                    'properties': {
                        'job-type': {
                            'type': 'string'
                        },
                        'comment': {
                            'type': 'string'
                        },
                        'ramp-slope': {
                            'type': 'number'
                        },
                        'distance': {
                            'type': 'number'
                        },
                        'max-depth-of-cut': {
                            'type': 'number'
                        },
                        'tool-diameter': {
                            'type': 'number'
                        },
                        'width-of-cut': {
                            'type': 'number'
                        },
                        'slot-max-depth-of-cut': {
                            'type': 'number'
                        },
                        'shoulder-max-depth-of-cut': {
                            'type': 'number'
                        },
                        'finishing-allowance': {
                            'type': 'number'
                        },
                        'work-holding-tabs': work_holding_tabs_schema
                    },
                    'required': [ 'job-type' ],
                    'additionalProperties': False
                }
            }
        },
        'additionalProperties': False
    }

    v2_schema = {
        'type': 'object',
        'properties': {
            'jobs': {
                'type': 'array',
                'items': {
                    'type': 'object',
                    'properties': {
                        'paths': {
                            'type': 'array',
                            'items': {
                                'type': 'number'
                            }
                        },
                        'operations': {
                            'type': 'array',
                            'items': {
                                'type': 'object',
                                'properties': {
                                    'engrave': {
                                        'type': 'object',
                                        'properties': { },
                                        'additionalProperties': False
                                    },
                                    'offset': {
                                        'type': 'object',
                                        'properties': {
                                            'distance': {
                                                'type': 'number'
                                            },
                                            'max-depth-of-cut': {
                                                'type': 'number'
                                            },
                                            'ramp-slope': {
                                                'type': 'number'
                                            },
                                            'work-holding-tabs': work_holding_tabs_schema
                                        },
                                        'additionalProperties': False
                                    },
                                    'pocket2': {
                                        'type': 'object',
                                        'properties': {
                                            'tool-diameter': {
                                                'type': 'number'
                                            },
                                            'width-of-cut': {
                                                'type': 'number'
                                            },
                                            'finishing-allowance': {
                                                'type': 'number'
                                            },
                                            'slot-max-depth-of-cut': {
                                                'type': 'number'
                                            },
                                            'shoulder-max-depth-of-cut': {
                                                'type': 'number'
                                            },
                                            'ramp-slope': {
                                                'type': 'number'
                                            }
                                        },
                                        'additionalProperties': False
                                    },
                                    'drill': {
                                        'type': 'object',
                                        'properties': { },
                                        'additionalProperties': False
                                    }
                                },
                                'additionalProperties': False
                            }
                        }
                    },
                    'additionalProperties': False
                }
            }
        },
        'additionalProperties': False
    }

    jobs = json.load(open(jobfile))

    jobfile_schema = None
    try:
        jsonschema.validate(jobs, v1_schema)
        jobfile_schema = 1
    except Exception as v1_e:
        try:
            jsonschema.validate(jobs, v2_schema)
            jobfile_schema = 2
        except Exception as v2_e:
            print("json fails schema validation (both v1 and v2)!", file=sys.stderr)
            print("v1 schema failure:", file=sys.stderr)
            print(v1_e, file=sys.stderr)
            print("v2 schema failure:", file=sys.stderr)
            print(v2_e, file=sys.stderr)
            raise SystemExit(1)

    return jobs, jobfile_schema


parser = argparse.ArgumentParser(description="Compute g-code operations from the closed paths in an SVG file.")
parser.add_argument("JOBFILE", help="Read machining job parameters from this file.")
parser.add_argument("SVG", help="The name of the SVG file to read.")
parser.add_argument("-p", "--path", type=int, action='append', help="Apply the machining operations to this path (specified as an index into the list of paths in the input SVG).  May be used multiple times to apply the operations to multiple paths.  (Default: apply to all paths.)")
parser.add_argument("-s", "--speed", type=int, help="The spindle speed to use, in RPM.  (Default: 1000 rpm.)")
parser.add_argument("-f", "--feed", type=float, help="The tool feed rate to use, in mm/minute.  Used by the 'engrave' and 'offset' job types.  (Default: 100.0 mm/min)")
parser.add_argument("--shoulder-feed", type=float, help="The tool feed rate to use for shoulder milling, in mm/minute.  Used by the 'pocket2' job type.  (Default: 90.0 mm/min)")
parser.add_argument("--slot-feed", type=float, help="The tool feed rate to use for slot milling, in mm/minute.  Used by the 'pocket2' job type'.  (Default: 75.0 mm/min)")
parser.add_argument("--plunge-feed", type=float, help="The tool feed rate to use for plunging cuts, in mm/minute.  Used by all job types.  (Default: 50.0 mm/min)")
parser.add_argument("--z-traverse", type=float, help="The Z level for safe traverses above the work and workholding.  (Default: 10)", default=10)
parser.add_argument("--z-approach", type=float, help="The Z level down to which we should rapid, before slowing to the feed rate to approach the work.  (Default: 0.5 mm above z-top-of-material)", default=None)
parser.add_argument("--z-top-of-material", type=float, help="The Z level where the cutting starts.  (Default: 0)", default=0)
parser.add_argument("--z-cut-depth", type=float, help="The Z level to cut down to.  Must be lower than --z-top-of-material.  (Default: -1)", default=-1.0)
parser.add_argument("--debug", action="store_true", help="Generate debugging output on stderr.  Useful for submitting bug reports.")
args = parser.parse_args()

if args.speed == None:
    print("WARNING: no --speed argument supplied, using the default 1000 rpm", file=sys.stderr)
    args.speed = 1000

if args.feed == None:
    print("WARNING: no --feed argument supplied, using the default 100 mm/min", file=sys.stderr)
    args.feed = 100.0

if args.shoulder_feed == None:
    print("WARNING: no --shoulder-feed argument supplied, using the default 90 mm/min", file=sys.stderr)
    args.shoulder_feed = 90

if args.slot_feed == None:
    print("WARNING: no --slot-feed argument supplied, using the default 75 mm/min", file=sys.stderr)
    args.slot_feed = 75

if args.plunge_feed == None:
    print("WARNING: no --plunge-feed argument supplied, using the default 50 mm/min", file=sys.stderr)
    args.plunge_feed = 50

if args.z_approach == None:
    args.z_approach = 0.5 + args.z_top_of_material

if args.z_top_of_material <= args.z_cut_depth:
    raise ValueError("--z-top-of-material (%f) is not above --z-cut-depth (%f)" % (args.z_top_of_material, args.z_cut_depth))

jobs, jobfile_schema = load_job_file(args.JOBFILE)
svg = gcoder.svg(args.SVG)

# G-code preamble
gcoder.metric()
gcoder.path_blend(tolerance=0.01)
gcoder.speed(args.speed)

output_paths = []


# Old-style job files have a single top-level property named "jobs",
# which is an array of v1 job objects.  Iterate over the paths from the
# command line, and run all jobs on each.
if jobfile_schema == 1:
    if args.path == None:
        args.path = range(0, len(svg.paths))
    for i in args.path:
        gcoder.comment("path %d" % i)
        input_path = svg.paths[i]
        for job in jobs['jobs']:
            output_paths.append(v1_handle_path(job, input_path))

# New-style job files have a single top-level property named "jobs",
# which is an array of v2 job objects.
elif jobfile_schema == 2:
    for job in jobs['jobs']:
        input_paths = None
        if type(args.path) is list and len(args.path) > 0:
            input_paths = args.path
        elif 'paths' in job:
            input_paths = job['paths']
        else:
            input_paths = range(0, len(svg.paths))
        for path in input_paths:
            gcoder.comment("path %d" % path)
            for op in job['operations']:
                output_paths.append(handle_operation(op, path))


#svgpathtools.paths2svg.wsvg(paths=[input_path] + output_paths)

# G-code postamble
gcoder.m2()
