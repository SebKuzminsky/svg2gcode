#!/usr/bin/env python3

#
# svg2gcode - a program for writing g-code from SVG files
#
# Copyright (C) 2018-2020 Sebastian Kuzminsky
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# 

import argparse
import json
import jsonschema
import math
import os
import sys

import gcoder

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'svgpathtools'))
import svgpathtools


class Result(object):
    """Abstract class to hold the result of an Operation."""

    def __init__(self):
        self.comment = []
        pass

    def emit(self):
        pass


class ResultComment(Result):
    """This class holds a G-code comment to emit."""

    def __init__(self, comment):
        self.comment = [comment]

    def emit(self):
        for comment in self.comment:
            print(";", comment)


class ResultFeed(Result):
    """This class holds a G-code F-word to emit."""

    def __init__(self, feed):
        self.comment = []
        self.feed = feed

    def emit(self):
        gcoder.set_feed_rate(self.feed)


class ResultG0(Result):
    """This class holds a G-code G0 command to emit."""

    def __init__(self, x=None, y=None, z=None):
        self.comment = []
        self.x = x
        self.y = y
        self.z = z

    def __str__(self):
        s = "ResultG0("
        separator = ""
        if self.x is not None:
            s += "%sx=%.4f" % (separator, self.x)
            separator = ", "
        if self.y is not None:
            s += "%sy=%.4f" % (separator, self.y)
            separator = ", "
        if self.z is not None:
            s += "%sz=%.4f" % (separator, self.z)
        s += ")"
        return s

    def emit(self):
        gcoder.g0(x=self.x, y=self.y, z=self.z)


class ResultG1(Result):
    """This class holds a G-code G1 command to emit."""

    def __init__(self, x=None, y=None, z=None):
        self.comment = []
        self.x = x
        self.y = y
        self.z = z

    def __str__(self):
        s = "ResultG1("
        separator = ""
        if self.x is not None:
            s += "%sx=%.4f" % (separator, self.x)
            separator = ", "
        if self.y is not None:
            s += "%sy=%.4f" % (separator, self.y)
            separator = ", "
        if self.z is not None:
            s += "%sz=%.4f" % (separator, self.z)
        s += ")"
        return s

    def emit(self):
        gcoder.g1(x=self.x, y=self.y, z=self.z)


class ResultDrill(Result):
    """This class holds the (X, Y) coordinate of a hole to drill."""

    def __init__(self, x, y, z_traverse, z_approach, z_cut_depth, plunge_feed, comment=None):
        self.comment = []
        if comment == None:
            pass;
        elif type(comment) == list:
            self.comment = comment
        else:
            self.comment.append(comment)

        self.x = x
        self.y = y
        self.z_traverse = z_traverse
        self.z_approach = z_approach
        self.z_cut_depth = z_cut_depth
        self.plunge_feed = plunge_feed

    def emit(self):
        for c in self.comment:
            gcoder.comment(c)

        gcoder.spindle_on()
        gcoder.g0(z=self.z_traverse)
        gcoder.g0(x=self.x, y=self.y)
        gcoder.set_feed_rate(self.plunge_feed)
        gcoder.g0(z=self.z_approach)
        gcoder.g81(z=self.z_cut_depth, retract=self.z_approach)
        gcoder.g0(z=self.z_traverse)


class ResultPath(Result):
    """This class holds the result of an Operation that produces a Path,
    to be turned into a sequence of G-code feed moves."""

    def __init__(self, svg, path, comment=None, z_traverse=10, z_approach=None, z_top_of_material=0, z_cut_depth=0, lead_in=True, lead_out=True, feed=None, plunge_feed=None, ramp_slope=None, max_depth_of_cut=None, work_holding_tabs=0, work_holding_tab_height=0.5, work_holding_tab_width=10.0, work_holding_tab_locations=[]):
        self.comment = []
        if comment == None:
            pass;
        elif type(comment) == list:
            self.comment = comment
        else:
            self.comment.append(comment)
        self.svg = svg
        self.path = path
        self.z_traverse = z_traverse
        self.z_approach = z_approach
        self.z_top_of_material = z_top_of_material
        self.z_cut_depth = z_cut_depth
        self.lead_in = lead_in
        self.lead_out = lead_out
        self.feed = feed
        self.plunge_feed = plunge_feed
        self.ramp_slope = ramp_slope
        self.max_depth_of_cut = max_depth_of_cut
        self.work_holding_tabs = work_holding_tabs
        self.work_holding_tab_height = work_holding_tab_height
        self.work_holding_tab_width = work_holding_tab_width
        self.work_holding_tab_locations = work_holding_tab_locations

    def emit(self):
        for c in self.comment:
            gcoder.comment(c)
        gcoder.path_to_gcode(
            self.svg,
            self.path,
            z_traverse=self.z_traverse,
            z_approach=self.z_approach,
            z_top_of_material=self.z_top_of_material,
            z_cut_depth=self.z_cut_depth,
            lead_in=self.lead_in,
            lead_out=self.lead_out,
            feed=self.feed,
            plunge_feed=self.plunge_feed,
            max_depth_of_cut=self.max_depth_of_cut,
            ramp_slope=self.ramp_slope,
            work_holding_tabs=self.work_holding_tabs,
            work_holding_tab_height=self.work_holding_tab_height,
            work_holding_tab_width=self.work_holding_tab_width,
            work_holding_tab_locations=self.work_holding_tab_locations,
            debug=args.debug
        )


class ResultTranslate(Result):
    """This class holds other Results, but translated."""

    def __init__(self, x, y, results):
        self.comment = []
        self.x = x
        self.y = y
        self.results = results

    def emit(self):
        for result in self.results:
            if isinstance(result, ResultG0):
                if result.x is not None:
                    result.x += self.x
                if result.y is not None:
                    result.y -= self.y
                result.emit()

            elif isinstance(result, ResultG1):
                if result.x is not None:
                    result.x += self.x
                if result.y is not None:
                    result.y -= self.y
                result.emit()

            elif isinstance(result, ResultDrill):
                result.x += self.x
                result.y -= self.y
                result.emit()

            elif isinstance(result, ResultPath):
                translated_path = result.path.translated(complex(self.x, self.y))
                result.path = translated_path
                result.emit()

            else:
                result.emit()


class ResultDuplicate(Result):
    """This class holds other Results, but duplicated."""

    def __init__(self, x_offset, y_offset, x_count, y_count, results):
        self.comment = []
        self.x_offset = x_offset
        self.y_offset = y_offset
        self.x_count = x_count
        self.y_count = y_count
        self.results = results

    def emit(self):
        for x in range(0, self.x_count):
            for y in range(0, self.y_count):
                x_offset = x * self.x_offset
                y_offset = y * self.y_offset

                for result in self.results:
                    if isinstance(result, ResultG0):
                        orig_x = result.x
                        orig_y = result.y
                        if result.x is not None:
                            result.x += x_offset
                        if result.y is not None:
                            result.y -= y_offset
                        result.emit()
                        result.x = orig_x
                        result.y = orig_y

                    elif isinstance(result, ResultG1):
                        orig_x = result.x
                        orig_y = result.y
                        if result.x is not None:
                            result.x += x_offset
                        if result.y is not None:
                            result.y -= y_offset
                        result.emit()
                        result.x = orig_x
                        result.y = orig_y

                    elif isinstance(result, ResultDrill):
                        orig_x = result.x
                        orig_y = result.y
                        if result.x is not None:
                            result.x += x_offset
                        if result.y is not None:
                            result.y -= y_offset
                        result.emit()
                        result.x = orig_x
                        result.y = orig_y

                    elif isinstance(result, ResultPath):
                        orig_path = result.path
                        translated_path = orig_path.translated(complex(x_offset, y_offset))
                        result.path = translated_path
                        result.emit()
                        result.path = orig_path

                    else:
                        result.emit()


def handle_operation(op, path_index):
    print("operation:", op, file=sys.stderr)
    print("path:", path_index, file=sys.stderr)

    input_path = svg.paths[path_index]

    input_path = gcoder.close_path(input_path)
    if not input_path.isclosed():
        raise ValueError("path is not closed")

    # positive area == clockwise path
    # negative area == counter-clockwise path
    # Make sure the input path is counter-clockwise.
    # FIXME: Only process counter-clockwise paths.  Clockwise paths are islands.  (Or the other way around)
    if gcoder.approximate_path_area(input_path) > 0:
        input_path = input_path.reversed()

    results = []

    # `operation` dicts always have exactly one property, which is a
    # string naming the operation type ("pocket", "offset", "drill", etc).
    # The value is a dict holding the operation-specific parameters.
    results.append(ResultComment("%s, path %d" % (list(op.keys())[0], path_index)))

    if 'engrave' in op:
        results += do_engrave(op['engrave'], input_path)

    elif 'offset' in op:
        results += do_offset(op['offset'], input_path)

    elif 'pocket' in op:
        results += do_pocket(op['pocket'], input_path)

    elif 'drill' in op:
        results += do_drill(op['drill'], input_path)

    elif 'translate' in op:
        results = do_translate(op['translate'], path_index)

    elif 'duplicate' in op:
        results = do_duplicate(op['duplicate'], path_index)

    else:
        raise SystemExit('unknown operation %s' % op)

    return results


def do_engrave(op_args, input_path):
    ramp_slope = None
    if "ramp-slope" in op_args:
        ramp_slope = op_args['ramp-slope']

    result = ResultPath(
        comment = "engrave path",
        svg=svg,
        path=input_path,
        z_traverse=args.z_traverse,
        z_approach=args.z_approach,
        z_top_of_material=args.z_top_of_material,
        z_cut_depth=args.z_cut_depth,
        plunge_feed=args.plunge_feed,
        feed=args.feed,
        ramp_slope=ramp_slope
    )

    return [result]


def do_offset(op_args, input_path):
    offset = op_args['distance']
    output_paths = gcoder.offset_paths(input_path, offset, debug=args.debug)

    max_depth_of_cut = None
    if "max-depth-of-cut" in op_args:
        max_depth_of_cut = op_args['max-depth-of-cut']
    else:
        cut_depth = args.z_top_of_material - args.z_cut_depth
        print("WARNING: no 'max-depth-of-cut' specified in job, slotting from --z-top-of-material (%f) down to --z-cut-depth (%f), total %f, in one pass" % (args.z_top_of_material, args.z_cut_depth, cut_depth), file=sys.stderr)

    ramp_slope = None
    if "ramp-slope" in op_args:
        ramp_slope = op_args['ramp-slope']

    work_holding_tabs = 0
    work_holding_tab_height = 0.5
    work_holding_tab_width = 10.0
    work_holding_tab_locations = []
    if "work-holding-tabs" in op_args:
        tabs = op_args['work-holding-tabs']
        if "number-of-tabs" in tabs:
            work_holding_tabs = tabs['number-of-tabs']
        if "height" in tabs:
            work_holding_tab_height = tabs['height']
        if "width" in tabs:
            work_holding_tab_width = tabs['width']
        if "locations" in tabs:
            work_holding_tab_locations = tabs['locations']

        if work_holding_tabs > 0 and len(work_holding_tab_locations) != 0:
            if work_holding_tabs != len(work_holding_tab_locations):
                raise ValueError("number of work holding tabs requested (%d) does not match number of locations specified (%d)" % (work_holding_tabs, len(work_holding_tab_locations)))

    results = []
    for i in range(len(output_paths)):
        result = ResultPath(
            comment = "offset path (%f offset) %d/%d" % (op_args['distance'], i+1, len(output_paths)),
            svg = svg,
            path = output_paths[i],
            z_traverse=args.z_traverse,
            z_approach=args.z_approach,
            z_top_of_material=args.z_top_of_material,
            z_cut_depth=args.z_cut_depth,
            lead_in=True,
            lead_out=True,
            plunge_feed=args.plunge_feed,
            feed=args.feed,
            max_depth_of_cut=max_depth_of_cut,
            ramp_slope=ramp_slope,
            work_holding_tabs=work_holding_tabs,
            work_holding_tab_height=work_holding_tab_height,
            work_holding_tab_width=work_holding_tab_width,
            work_holding_tab_locations=work_holding_tab_locations
        )
        results.append(result)

    return results


def do_drill(op_args, input_path):
    if len(input_path) == 2 and \
        type(input_path[0]) == svgpathtools.path.Arc and \
        type(input_path[1]) == svgpathtools.path.Arc and \
        gcoder.close_enough(input_path[0].center, input_path[1].center) and \
        gcoder.close_enough(input_path[0].start, input_path[1].end) and \
        gcoder.close_enough(input_path[0].end, input_path[1].start) and \
        gcoder.close_enough(input_path[0].radius, input_path[1].radius) and \
        input_path[0].sweep == input_path[1].sweep and \
        gcoder.close_enough(input_path[0].radius.real, input_path[0].radius.imag):
        # input path is a circle, ok
        pass
    else:
        raise ValueError('drill job on non-circle path!')

    (x, y) = svg.xy_to_mm(input_path[0].center)
    result = ResultDrill(
        x=x,
        y=y,
        z_traverse=args.z_traverse,
        z_approach=args.z_approach,
        z_cut_depth=args.z_cut_depth,
        plunge_feed=args.plunge_feed,
        comment="hole diameter %.4f" % (input_path[0].radius.real * 2)
    )
    return [result]


def v1_handle_path(job, path_index):
    if args.debug: print("doing v1 job", file=sys.stderr)
    if args.debug: print("    job: %s" % job['job-type'], file=sys.stderr)
    if args.debug: print("    path: %s" % path_index, file=sys.stderr)

    results = []

    input_path = gcoder.close_path(svg.paths[path_index])
    if not input_path.isclosed():
        raise ValueError("path is not closed")

    # positive area == clockwise path
    # negative area == counter-clockwise path
    # Make sure the input path is counter-clockwise.
    # FIXME: Only process counter-clockwise paths.  Clockwise paths are islands.  (Or the other way around)
    if gcoder.approximate_path_area(input_path) > 0:
        input_path = input_path.reversed()

    if job['job-type'] == 'offset':
        results = do_offset(job, input_path)

    elif job['job-type'] == 'pocket':
        results = do_pocket(job, input_path)

    elif job['job-type'] == 'engrave':
        results = do_engrave(job, input_path)

    elif job['job-type'] == 'drill':
        results = do_drill(job, input_path)

    else:
        raise ValueError('unknown job type %s' % job['job-type'])

    for r in results:
        print("r: %s" % r, file=sys.stderr)
        r.comment.insert(0, "%s, path %d" % (job['job-type'], path_index))

    return results


def remove_island(island, tool_radius, width_of_cut):
    offset = -tool_radius + width_of_cut
    island_output_paths = []

    print("removing an island: %s" % island, file=sys.stderr)

    while island != None:
        print("remaining material:", island, file=sys.stderr)

        shoulder_milling_paths = gcoder.offset_paths(island, offset, debug=args.debug)

        if len(shoulder_milling_paths) == 0:
            print("no more shoulder milling paths", file=sys.stderr)
            return island_output_paths

        island_output_paths += shoulder_milling_paths

        remaining_material_contours = []
        for path in shoulder_milling_paths:
            remaining_material_contours += gcoder.offset_paths(path, tool_radius, debug=args.debug)

        num_islands = len(remaining_material_contours)
        print("%d sub-islands remaining" % num_islands, file=sys.stderr)
        if num_islands == 0:
            # Done!
            return island_output_paths

        elif num_islands == 1:
            # Just one island, iterate on it.
            island = remaining_material_contours[0]

        else:
            # Multiple islands, recurse on each one.
            for island in remaining_material_contours:
                island_output_paths += remove_island(island, tool_radius, width_of_cut)
            return island_output_paths


def do_pocket(op_args, input_path):
    #
    # Inset the material contour by the finishing allowance (if any)
    # to get the rough material contour.
    #
    # The first tool path is the perimeter slotting cut (which might be
    # wrong, shouldn't we make the smallest possible slot in the middle
    # and go out from there?). Inset the rough material contour by the
    # tool radius to get the tool path for this wrong slot.
    #
    # After that we want to shoulder mill the remainder.  Inset the
    # slotting tool path by the tool radius to find the remaining
    # material contour.
    #
    # While the remaining material contour is greater than zero:
    #
    #     Outset the remaining material contour by the tool radius minus
    #     the width of cut to find the next pass tool path.
    #
    #     Inset the tool path by the tool radius to find the new remaining
    #     material contour.
    #
    # If a finishing cut was requested, inset the original material
    # contour by the tool radius to find the finishing pass tool path
    # and shoulder mill.
    #

    output_paths = []
    material_contour = input_path

    # FIXME: get these from a different tool info section of the json data
    if "tool-diameter" in op_args:
        tool_diameter = op_args['tool-diameter']
    else:
        raise ValueError('no "tool-diameter" specified in "pocket" operation')
    tool_radius = tool_diameter / 2.0

    if "width-of-cut" in op_args:
        width_of_cut = op_args['width-of-cut']
    else:
        raise ValueError('no "width-of-cut" specified in "pocket" operation')


    #
    # Deal with finishing.  This is complicated a bit by having to
    # support the deprecated `pocket.finishing-allowance` and the new
    # `pocket.finishing`.
    #
    # The default `finishing['allowance'] value of 0.0 here means "no
    # finishing at all".
    #

    finishing = {
        'allowance': 0.0,
        'behavior': 'single-pass'
    }

    if "finishing-allowance" in op_args:
        print("WARNING: `pocket.finishing-allowance` is deprecated, use `pocket.finishing.allowance` instead.", file=sys.stderr)
        print("i'll let it slide just this once", file=sys.stderr)
        finishing['allowance'] = op_args['finishing-allowance']
        finishing['behavior'] = 'none'

    if "finishing" in op_args:
        if 'allowance' in op_args['finishing']:
            if op_args['finishing']['allowance'] <= 0.0:
                raise ValueError("`pocket.finishing.allowance` must be > 0.0")
            finishing['allowance'] = op_args['finishing']['allowance']
        else:
            finishing['allowance'] = 0.5

        if 'behavior' in op_args['finishing']:
            if finishing['behavior'] not in [ 'none', 'progressive', 'single-pass' ]:
                raise ValueError(f"`pocket.finishing.behavior` has invalid value '{op_args['finishing']['behavior']}'")
            finishing['behavior'] = op_args['finishing']['behavior']
        else:
            finishing['behavior'] = 'single-pass'

    pocket_depth = args.z_top_of_material - args.z_cut_depth

    slot_max_depth_of_cut = pocket_depth
    if "slot-max-depth-of-cut" in op_args:
        slot_max_depth_of_cut = op_args['slot-max-depth-of-cut']
    else:
        print("WARNING: no 'slot-max-depth-of-cut' specified in pocket operation, slotting from --z-top-of-material (%f) down to --z-cut-depth (%f), total %f, in one pass" % (args.z_top_of_material, args.z_cut_depth, pocket_depth), file=sys.stderr)

    shoulder_max_depth_of_cut = pocket_depth
    if "shoulder-max-depth-of-cut" in op_args:
        shoulder_max_depth_of_cut = op_args['shoulder-max-depth-of-cut']
    else:
        print("WARNING: no 'shoulder-max-depth-of-cut' specified in pocket operation, slotting from --z-top-of-material (%f) down to --z-cut-depth (%f), total %f, in one pass" % (args.z_top_of_material, args.z_cut_depth, pocket_depth), file=sys.stderr)

    max_depth_of_cut = min(slot_max_depth_of_cut, shoulder_max_depth_of_cut)
    num_passes = math.ceil(pocket_depth / max_depth_of_cut)
    depth_of_cut = pocket_depth / num_passes

    ramp_slope = None
    if "ramp-slope" in op_args:
        ramp_slope = op_args['ramp-slope']


    #
    # Compute initial slotting paths.
    #

    offset = finishing['allowance'] + tool_radius
    slotting_paths = gcoder.offset_paths(material_contour, offset, debug=args.debug)
    if not slotting_paths:
        print("no slotting path!", file=sys.stderr)
        return []
    output_paths += slotting_paths
    print("initial slotting path(s): %s" % slotting_paths, file=sys.stderr)


    #
    # Compute shoulder milling paths.
    #

    shoulder_milling_paths = []
    for slot in slotting_paths:
        remaining_material_contours = gcoder.offset_paths(slot, tool_radius, debug=args.debug)
        print("remaining material contours (islands): %s" % remaining_material_contours, file=sys.stderr)
        output_paths += remaining_material_contours
        # FIXME: sort the remaining islands, nearest first
        # FIXME: Keep track of the islands separately, and within each
        #     island only raise the tool to the top of material within this
        #     pocketing op.
        for island in remaining_material_contours:
            shoulder_milling_paths += remove_island(island, tool_radius, width_of_cut)
    output_paths += shoulder_milling_paths


    #
    # Compute finishing paths, if any.
    #

    if finishing['allowance'] > 0.0:
        finishing_paths = gcoder.offset_paths(material_contour, tool_radius, debug=args.debug)
        if not finishing_paths:
            print("no finishing path!", file=sys.stderr)
            return []
        output_paths += finishing_paths
        print("finishing path(s): %s" % finishing_paths, file=sys.stderr)
    else:
        finishing_paths = [ ]


    #
    # Emit all the g-code.
    #
    results = []
    pass_num = 0
    while pass_num < num_passes:
        pass_num += 1
        z = args.z_top_of_material - (depth_of_cut * pass_num)
        z_prev = args.z_top_of_material - (depth_of_cut * (pass_num - 1))

        for path in slotting_paths:
            result = ResultPath(
                comment="slotting cut %d/%d, z=%f, %.4f finishing allowance + %.4f tool radius" % (pass_num, num_passes, z, finishing['allowance'], tool_radius),
                svg=svg,
                path=path,
                z_traverse=args.z_traverse,
                z_approach=args.z_approach,
                z_top_of_material=z_prev,
                z_cut_depth=z,
                lead_in=True,
                lead_out=False,
                plunge_feed=args.plunge_feed,
                feed=args.slot_feed,
                ramp_slope=ramp_slope
            )
            results.append(result)

        for path in shoulder_milling_paths:
            # The tool is currently down on the floor of the pocket.
            results.append(ResultComment("pocket shoulder-milling path"))

            # FIXME: if we can reach it without gouging, just feed there
            # else this:
            # Come up out of the pocket.
            results.append(ResultG1(z=args.z_approach))
            results.append(ResultG0(z=args.z_traverse))

            # Rapid over to the beginning of the next path.
            (x, y) = svg.xy_to_mm(path[0].start)
            results.append(ResultG0(x=x, y=y))
            results.append(ResultG0(z=args.z_approach))

            # Plunge down into the beginning of the next path.
            # FIXME: should optionally use ramp entry here
            results.append(ResultFeed(args.plunge_feed))
            results.append(ResultG1(z=z))

            result = ResultPath(
                svg=svg,
                path=path,
                z_traverse=args.z_traverse,
                z_approach=args.z_approach,
                z_top_of_material=z_prev,
                z_cut_depth=z,
                lead_in=False,
                lead_out=False,
                feed=args.shoulder_feed
            )
            results.append(result)

        if finishing['behavior'] == 'progressive':
            for path in finishing_paths:
                result = ResultPath(
                    comment="progressive finishing cut %d/%d, z=%f, %.4f tool radius" % (pass_num, num_passes, z, tool_radius),
                    svg=svg,
                    path=path,
                    z_traverse=args.z_traverse,
                    z_approach=args.z_approach,
                    z_top_of_material=z_prev,
                    z_cut_depth=z,
                    lead_in=True,
                    lead_out=False,
                    plunge_feed=args.plunge_feed,
                    feed=args.shoulder_feed,
                    ramp_slope=ramp_slope
                )
                results.append(result)

    # The tool is left down on the floor of the pocket, raise it
    # up now.
    results.append(ResultG1(z=args.z_approach))
    results.append(ResultG0(z=args.z_traverse))

    if finishing['behavior'] == 'single-pass':
        for path in finishing_paths:
            result = ResultPath(
                comment="single-pass finishing cut, z=%f, %.4f tool radius" % (z, tool_radius),
                svg=svg,
                path=path,
                z_traverse=args.z_traverse,
                z_approach=args.z_approach,
                z_top_of_material=args.z_top_of_material,
                z_cut_depth=z,
                lead_in=True,
                lead_out=True,
                plunge_feed=args.plunge_feed,
                feed=args.shoulder_feed,
                ramp_slope=ramp_slope
            )
            results.append(result)

        # The lead_out moved the tool up out of the pocket and left it
        # at Z=z_traverse.

    return results


def do_translate(op_args, path_index):
    if 'x' not in op_args:
        op_args['x'] = 0.0
    if 'y' not in op_args:
        op_args['y'] = 0.0

    results = []
    for op in op_args['operations']:
        results += handle_operation(op, path_index)

    return [ResultTranslate(op_args['x'], op_args['y'], results)]


def do_duplicate(op_args, path_index):
    if 'x-offset' not in op_args:
        op_args['x-offset'] = 0.0
    if 'y-offset' not in op_args:
        op_args['y-offset'] = 0.0
    if 'x-count' not in op_args:
        op_args['x-count'] = 1
    if 'y-count' not in op_args:
        op_args['y-count'] = 1

    results = []
    for op in op_args['operations']:
        results += handle_operation(op, path_index)

    return [ResultDuplicate(op_args['x-offset'], op_args['y-offset'], op_args['x-count'], op_args['y-count'], results)]


def load_job_file(jobfile):
    work_holding_tabs_schema = {
        'type': 'object',
        'properties': {
            'number-of-tabs': {
                'type': 'integer'
            },
            'height': {
                'type': 'number'
            },
            'width': {
                'type': 'number'
            },
            'locations': {
                'type': 'array',
                'items': {
                    'type': 'number'
                }
            }
        },
        'additionalProperties': False
    }

    pocket_finishing_schema = {
        'type': 'object',
        'properties': {
            'allowance': {
                'type': 'number'
            },
            'behavior': {
                'type': 'string'
            }
        },
        'additionalProperties': False
    }

    v1_schema = {
        'type': 'object',
        'properties': {
            'jobs': {
                'type': 'array',
                'items': {
                    'type': 'object',
                    'properties': {
                        'job-type': {
                            'type': 'string'
                        },
                        'comment': {
                            'type': 'string'
                        },
                        'ramp-slope': {
                            'type': 'number'
                        },
                        'distance': {
                            'type': 'number'
                        },
                        'max-depth-of-cut': {
                            'type': 'number'
                        },
                        'tool-diameter': {
                            'type': 'number'
                        },
                        'width-of-cut': {
                            'type': 'number'
                        },
                        'slot-max-depth-of-cut': {
                            'type': 'number'
                        },
                        'shoulder-max-depth-of-cut': {
                            'type': 'number'
                        },
                        'finishing-allowance': {
                            'type': 'number'
                        },
                        'work-holding-tabs': work_holding_tabs_schema
                    },
                    'required': [ 'job-type' ],
                    'additionalProperties': False
                }
            }
        },
        'additionalProperties': False
    }

    basic_operations = {
        'engrave': {
            'type': 'object',
            'properties': {
                'ramp-slope': {
                    'type': 'number'
                }
            },
            'additionalProperties': False
        },
        'offset': {
            'type': 'object',
            'properties': {
                'distance': {
                    'type': 'number'
                },
                'max-depth-of-cut': {
                    'type': 'number'
                },
                'ramp-slope': {
                    'type': 'number'
                },
                'work-holding-tabs': work_holding_tabs_schema
            },
            'required': [ 'distance' ],
            'additionalProperties': False
        },
        'pocket': {
            'type': 'object',
            'properties': {
                'tool-diameter': {
                    'type': 'number'
                },
                'width-of-cut': {
                    'type': 'number'
                },
                'slot-max-depth-of-cut': {
                    'type': 'number'
                },
                'shoulder-max-depth-of-cut': {
                    'type': 'number'
                },
                'ramp-slope': {
                    'type': 'number'
                },
                # FIXME: Remove `finishing-allowance`, the `finishing`
                # object takes care of this now.
                'finishing-allowance': {
                    'type': 'number'
                },
                'finishing': pocket_finishing_schema
            },
            'required': [ 'tool-diameter', 'width-of-cut' ],
            'additionalProperties': False
        },
        'drill': {
            'type': 'object',
            'properties': { },
            'additionalProperties': False
        }
    }

    translate_operation = {
        'translate': {
            'type': 'object',
            'properties': {
                'x': {
                    'type': 'number'
                },
                'y': {
                    'type': 'number'
                },
                'operations': {
                    'type': 'array',
                    'items': basic_operations
                }
            },
            'required': [ 'operations' ],
            'additionalProperties': False
        }
    }

    duplicate_operation = {
        'duplicate': {
            'type': 'object',
            'properties': {
                'x-offset': {
                    'type': 'number'
                },
                'y-offset': {
                    'type': 'number'
                },
                'x-count': {
                    'type': 'integer'
                },
                'y-count': {
                    'type': 'integer'
                },
                'operations': {
                    'type': 'array',
                    'items': basic_operations
                }
            }
        }
    }

    operations = {}
    operations.update(basic_operations)
    operations.update(translate_operation)
    operations.update(duplicate_operation)

    v2_schema = {
        'type': 'object',
        'properties': {
            'jobs': {
                'type': 'array',
                'items': {
                    'type': 'object',
                    'properties': {
                        'paths': {
                            'type': 'array',
                            'items': {
                                'type': 'number'
                            }
                        },
                        'operations': {
                            'type': 'array',
                            'items': {
                                'type': 'object',
                                'properties': operations,
                                'minProperties': 1,
                                'maxProperties': 1,
                                'additionalProperties': False
                            }
                        }
                    },
                    'additionalProperties': False
                }
            }
        },
        'additionalProperties': False
    }

    jsonschema.Draft4Validator.check_schema(v1_schema)
    jsonschema.Draft4Validator.check_schema(v2_schema)

    jobs = json.load(open(jobfile))

    jobfile_schema = None
    try:
        jsonschema.validate(jobs, v2_schema)
        jobfile_schema = 2
    except Exception as v2_e:
        try:
            jsonschema.validate(jobs, v1_schema)
            jobfile_schema = 1
        except Exception as v1_e:
            print("json fails schema validation (both v1 and v2)!", file=sys.stderr)
            print("v1 schema failure:", file=sys.stderr)
            print(v1_e, file=sys.stderr)
            print("v2 schema failure:", file=sys.stderr)
            print(v2_e, file=sys.stderr)
            raise SystemExit(1)

    return jobs, jobfile_schema


parser = argparse.ArgumentParser(description="Compute g-code operations from the closed paths in an SVG file.")
parser.add_argument("JOBFILE", help="Read machining job parameters from this file.")
parser.add_argument("SVG", help="The name of the SVG file to read.")
parser.add_argument("--gcode-origin", choices=['viewbox-lower-left', 'svg-origin'], default='viewbox-lower-left', help="See the manpage for a fuller dicussion of this option.  (Default: 'viewbox-lower-left'.)")
parser.add_argument("-p", "--path", type=int, action='append', help="Apply the machining operations to this path (specified as an index into the list of paths in the input SVG).  May be used multiple times to apply the operations to multiple paths.  (Default: apply to all paths.)")
parser.add_argument("-s", "--speed", type=int, help="The spindle speed to use, in RPM.  (Default: 1000 rpm.)")
parser.add_argument("-f", "--feed", type=float, help="The tool feed rate to use, in mm/minute.  Used by the 'engrave' and 'offset' job types.  (Default: 100.0 mm/min)")
parser.add_argument("--shoulder-feed", type=float, help="The tool feed rate to use for shoulder milling, in mm/minute.  Used by the 'pocket' operation.  (Default: 90.0 mm/min)")
parser.add_argument("--slot-feed", type=float, help="The tool feed rate to use for slot milling, in mm/minute.  Used by the 'pocket' operation'.  (Default: 75.0 mm/min)")
parser.add_argument("--plunge-feed", type=float, help="The tool feed rate to use for plunging cuts, in mm/minute.  Used by all job types.  (Default: 50.0 mm/min)")
parser.add_argument("--z-traverse", type=float, help="The Z level for safe traverses above the work and workholding.  (Default: 10)", default=10)
parser.add_argument("--z-approach", type=float, help="The Z level down to which we should rapid, before slowing to the feed rate to approach the work.  (Default: 0.5 mm above z-top-of-material)", default=None)
parser.add_argument("--z-top-of-material", type=float, help="The Z level where the cutting starts.  (Default: 0)", default=0)
parser.add_argument("--z-cut-depth", type=float, help="The Z level to cut down to.  Must be lower than --z-top-of-material.  (Default: -1)", default=-1.0)
parser.add_argument("--debug", action="store_true", help="Generate debugging output on stderr.  Useful for submitting bug reports.")
parser.add_argument("--precision", metavar="DISTANCE", type=float, help="Distance threshold for merging operations", default=1e-5)
parser.add_argument("--step-length", metavar="DISTANCE", type=float, help="Approximate step length when splitting curves in segments (mm).", default=1.0)
args = parser.parse_args()

if args.speed == None:
    print("NOTE: no --speed argument supplied, using the default 1000 rpm", file=sys.stderr)
    args.speed = 1000

if args.feed == None:
    print("NOTE: no --feed argument supplied, using the default 100 mm/min", file=sys.stderr)
    args.feed = 100.0

if args.shoulder_feed == None:
    print("NOTE: no --shoulder-feed argument supplied, using the default 90 mm/min", file=sys.stderr)
    args.shoulder_feed = 90

if args.slot_feed == None:
    print("NOTE: no --slot-feed argument supplied, using the default 75 mm/min", file=sys.stderr)
    args.slot_feed = 75

if args.plunge_feed == None:
    print("NOTE: no --plunge-feed argument supplied, using the default 50 mm/min", file=sys.stderr)
    args.plunge_feed = 50

if args.z_approach == None:
    args.z_approach = 0.5 + args.z_top_of_material

if args.z_top_of_material <= args.z_cut_depth:
    raise ValueError("--z-top-of-material (%f) is not above --z-cut-depth (%f)" % (args.z_top_of_material, args.z_cut_depth))

jobs, jobfile_schema = load_job_file(args.JOBFILE)

if args.gcode_origin == 'viewbox-lower-left':
    gcode_origin=gcoder.svg.GCODE_ORIGIN_IS_VIEWBOX_LOWER_LEFT
elif args.gcode_origin == 'svg-origin':
    gcode_origin=gcoder.svg.GCODE_ORIGIN_IS_SVG_ORIGIN
svg = gcoder.svg(args.SVG, gcode_origin)

# G-code preamble
gcoder.metric()
gcoder.path_blend(tolerance=0.01)
gcoder.speed(args.speed)

results = []


# Old-style job files have a single top-level property named "jobs",
# which is an array of v1 job objects.  Iterate over the paths from the
# command line, and run all jobs on each.
if jobfile_schema == 1:
    if args.path == None:
        args.path = list(range(0, len(svg.paths)))
    for path_index in args.path:
        for job in jobs['jobs']:
            results += v1_handle_path(job, path_index)

# New-style job files have a single top-level property named "jobs",
# which is an array of v2 job objects.
elif jobfile_schema == 2:
    for job in jobs['jobs']:
        input_paths = None
        if type(args.path) is list and len(args.path) > 0:
            input_paths = args.path
        elif 'paths' in job:
            input_paths = job['paths']
        else:
            input_paths = list(range(0, len(svg.paths)))
        for path in input_paths:
            for op in job['operations']:
                results += handle_operation(op, path)


output_paths = []
for result in results:
    result.emit()
    if type(result) == ResultPath:
        output_paths += result.path


if args.debug:
    print("output paths: %s" % output_paths, file=sys.stderr)
    if len(output_paths) > 0:
        svgpathtools.paths2svg.wsvg(paths=output_paths, filename=os.path.join(os.getcwd(), 'disvg_output.svg'))

# G-code postamble
gcoder.m2()
